<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Games - Chace Liu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #9b59b6 100%);
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            color: #ffffff;
            line-height: 1.6;
            padding: 20px 0;
            overflow-x: hidden;
        }

        .container {
            text-align: center;
            max-width: 900px;
            padding: 40px 20px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            border: 4px solid transparent;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.12)),
                conic-gradient(from 0deg, #0080ff, #0066cc, #004499, #0080ff, #00aaff, #0080ff);
            background-origin: border-box;
            background-clip: padding-box, border-box;
            animation: fadeInUp 0.8s ease-out;
            position: relative;
            overflow: hidden;
        }

        .container::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            background: conic-gradient(from 0deg,
                #0080ff 0deg, #0066cc 60deg, #004499 120deg,
                #0080ff 180deg, #00aaff 240deg, #0080ff 300deg, #0080ff 360deg);
            border-radius: 30px;
            z-index: -2;
            animation: spinBorder 8s linear infinite;
        }

        .container::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg,
                rgba(0, 128, 255, 0.8) 0%,
                rgba(0, 102, 204, 0.6) 25%,
                rgba(0, 68, 153, 0.8) 50%,
                rgba(0, 170, 255, 0.6) 75%,
                rgba(0, 128, 255, 0.8) 100%);
            background-size: 400% 400%;
            border-radius: 27px;
            z-index: -1;
            animation: gradientFlow 6s ease-in-out infinite, pulse 4s ease-in-out infinite;
            filter: blur(1px);
        }

        @keyframes spinBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 100% 100%; }
            75% { background-position: 0% 100%; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.01); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #ffffff 0%, #f8f9fa 25%, #e9ecef 50%, #ffffff 75%, #f8f9fa 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            letter-spacing: -0.02em;
            animation: textShimmer 3s ease-in-out infinite;
            position: relative;
        }

        @keyframes textShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .accent-line {
            width: 120px;
            height: 6px;
            background: linear-gradient(90deg,
                transparent,
                #0080ff 10%,
                #0066cc 25%,
                #004499 50%,
                #0066cc 75%,
                #0080ff 90%,
                transparent);
            margin: 2rem auto;
            border-radius: 6px;
            opacity: 0.9;
            animation: lineGlow 2s ease-in-out infinite alternate;
            box-shadow:
                0 0 15px rgba(0, 128, 255, 0.6),
                0 0 30px rgba(0, 102, 204, 0.4),
                inset 0 0 10px rgba(0, 170, 255, 0.3);
            position: relative;
            border: 2px solid transparent;
            background-image:
                linear-gradient(90deg, transparent, #0080ff 10%, #0066cc 25%, #004499 50%, #0066cc 75%, #0080ff 90%, transparent),
                conic-gradient(from 0deg, #0080ff, #0066cc, #004499, #0080ff);
            background-origin: border-box;
            background-clip: padding-box, border-box;
        }

        .accent-line::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(90deg,
                rgba(0, 128, 255, 0.8) 0%,
                rgba(0, 102, 204, 0.6) 25%,
                rgba(0, 68, 153, 0.8) 50%,
                rgba(0, 170, 255, 0.6) 75%,
                rgba(0, 128, 255, 0.8) 100%);
            background-size: 200% 200%;
            border-radius: 9px;
            z-index: -1;
            animation: accentFlow 4s ease-in-out infinite;
            filter: blur(1px);
        }

        .accent-line::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: conic-gradient(from 0deg,
                #0080ff 0deg, #0066cc 120deg, #004499 240deg, #0080ff 360deg);
            border-radius: 7px;
            z-index: -1;
            animation: spinAccent 6s linear infinite;
        }

        @keyframes accentFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes spinAccent {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes lineGlow {
            0% { opacity: 0.7; transform: scaleX(0.8); }
            100% { opacity: 1; transform: scaleX(1); }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px 0;
            }

            .container {
                margin: 10px;
                padding: 25px 15px;
                max-width: 95vw;
            }

            .container::before {
                top: -4px;
                left: -4px;
                right: -4px;
                bottom: -4px;
                border-radius: 28px;
            }

            .container::after {
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 26px;
            }

            .game-card::before {
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 26px;
            }

            .game-button::before {
                top: -1px;
                left: -1px;
                right: -1px;
                bottom: -1px;
                border-radius: 31px;
            }

            .accent-line::before {
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 8px;
            }

            h1 {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px 10px;
            }

            .container::before {
                top: -3px;
                left: -3px;
                right: -3px;
                bottom: -3px;
                border-radius: 27px;
            }

            .container::after {
                top: -1px;
                left: -1px;
                right: -1px;
                bottom: -1px;
                border-radius: 25px;
            }

            .accent-line {
                height: 5px;
            }

            .accent-line::before {
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 7px;
            }

            .accent-line::after {
                border-radius: 6px;
            }

            h1 {
                font-size: 2rem;
            }
        }

        /* Subtle floating animation */
        .container {
            animation: fadeInUp 0.8s ease-out, float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }


        /* Enhanced Navigation Button Styles */
        .nav-button {
            display: inline-block;
            padding: 16px 32px;
            margin: 2rem 0;
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4, #45B7D1, #96CEB4, #FECA57, #FF9FF3);
            background-size: 400% 400%;
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.35);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            backdrop-filter: blur(15px);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: gradientShift 6s ease infinite, buttonFloat 4s ease-in-out infinite;
            cursor: pointer;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .nav-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            animation-duration: 1s;
        }

        .nav-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            25% { background-position: 100% 30%; }
            50% { background-position: 100% 70%; }
            75% { background-position: 0% 70%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes buttonFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-2px) rotate(0.5deg); }
            66% { transform: translateY(-1px) rotate(-0.5deg); }
        }

        /* Games Section Styles */
        .games-section {
            margin-top: 3rem;
            padding: 2rem 0;
        }

        .games-title {
            font-size: 2.5rem;
            font-weight: 600;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #FF6B6B 0%, #4ECDC4 25%, #45B7D1 50%, #96CEB4 75%, #FECA57 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleShimmer 4s ease-in-out infinite;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            letter-spacing: -0.02em;
        }

        @keyframes titleShimmer {
            0%, 100% { background-position: 0% 50%; opacity: 1; }
            50% { background-position: 100% 50%; opacity: 0.9; }
        }

        @keyframes shimmer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 2rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin: 2rem auto;
            max-width: 800px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        #gameCanvas {
            border: 3px solid rgba(255, 255, 255, 0.35);
            border-radius: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1a2238 100%);
            display: block;
            margin: 0 auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            transition: all 0.3s ease;
        }

        #gameCanvas:hover {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.1) inset;
        }

        .game-controls {
            text-align: center;
            margin-top: 1.5rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
        }

        .game-controls h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #ffffff;
        }

        .game-controls p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.9);
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            text-align: center;
        }

        .score, .lives, .level, .timer, .pairs, .moves, .plants, .water, .seeds {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Game-specific stat visibility */
        .game-info .timer { opacity: 0.3; }
        .game-info .pairs { opacity: 0.3; }
        .game-info .moves { opacity: 0.3; }
        .game-info .plants { opacity: 0.3; }
        .game-info .water { opacity: 0.3; }
        .game-info .seeds { opacity: 0.3; }

        /* Active game stats */
        .game-info .timer.active { opacity: 1; }
        .game-info .pairs.active { opacity: 1; }
        .game-info .moves.active { opacity: 1; }
        .game-info .plants.active { opacity: 1; }
        .game-info .water.active { opacity: 1; }
        .game-info .seeds.active { opacity: 1; }

        .game-button {
            display: inline-block;
            padding: 14px 28px;
            margin: 0.5rem;
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4, #45B7D1);
            background-size: 200% 200%;
            color: white;
            text-decoration: none;
            border: 3px solid transparent;
            background-image:
                linear-gradient(135deg, #FF6B6B, #4ECDC4, #45B7D1),
                linear-gradient(90deg, #0080ff, #0066cc, #004499, #0080ff, #00aaff);
            background-origin: border-box;
            background-clip: padding-box, border-box;
            border-radius: 30px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow:
                0 8px 20px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                0 0 15px rgba(0, 128, 255, 0.5),
                inset 0 0 15px rgba(0, 128, 255, 0.2);
            backdrop-filter: blur(10px);
            animation: buttonGradientShift 3s ease infinite;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: conic-gradient(from 0deg,
                #0080ff 0deg, #0066cc 120deg, #004499 240deg, #0080ff 360deg);
            border-radius: 32px;
            z-index: -1;
            animation: rotateButtonBorder 5s linear infinite;
        }

        .game-button::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(0, 128, 255, 0.7) 0%,
                rgba(0, 102, 204, 0.5) 25%,
                rgba(0, 68, 153, 0.7) 50%,
                rgba(0, 170, 255, 0.5) 75%,
                rgba(0, 128, 255, 0.7) 100%);
            background-size: 300% 300%;
            border-radius: 31px;
            z-index: -1;
            animation: flowButtonBorder 7s ease-in-out infinite;
            filter: blur(0.5px);
        }

        @keyframes rotateButtonBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes flowButtonBorder {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes buttonGradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow:
                0 12px 25px rgba(0, 0, 0, 0.35),
                0 0 15px rgba(255, 255, 255, 0.2) inset,
                0 0 25px rgba(0, 128, 255, 0.8),
                inset 0 0 25px rgba(0, 128, 255, 0.3);
            animation-duration: 1.5s;
        }

        .game-button:hover::before {
            animation-duration: 2.5s;
        }

        .game-button:hover::after {
            animation-duration: 3.5s;
            filter: blur(0.3px);
        }

        .game-button:active {
            transform: translateY(0);
        }

        /* Game Grid Styles */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            padding: 2rem 0;
            max-width: 1000px;
            margin: 0 auto;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 2.5rem;
            text-align: center;
            border: 3px solid transparent;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.15)),
                linear-gradient(135deg, #0080ff, #0066cc, #004499, #0080ff, #00aaff);
            background-origin: border-box;
            background-clip: padding-box, border-box;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow:
                0 15px 35px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                0 0 30px rgba(0, 128, 255, 0.4),
                inset 0 0 25px rgba(0, 128, 255, 0.15);
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: conic-gradient(from 0deg,
                #0080ff 0deg, #0066cc 72deg, #004499 144deg,
                #0080ff 216deg, #00aaff 288deg, #0080ff 360deg);
            border-radius: 27px;
            z-index: -1;
            animation: rotateGameBorder 10s linear infinite;
        }

        .game-card::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg,
                rgba(0, 128, 255, 0.6) 0%,
                rgba(0, 102, 204, 0.4) 25%,
                rgba(0, 68, 153, 0.6) 50%,
                rgba(0, 170, 255, 0.4) 75%,
                rgba(0, 128, 255, 0.6) 100%);
            background-size: 400% 400%;
            border-radius: 25px;
            z-index: -1;
            animation: flowGameBorder 12s ease-in-out infinite;
            filter: blur(0.8px);
        }

        @keyframes rotateGameBorder {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes flowGameBorder {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 25%; }
            50% { background-position: 100% 75%; }
            75% { background-position: 0% 100%; }
        }

        .game-card:hover {
            transform: translateY(-12px) scale(1.02);
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.35),
                0 0 20px rgba(255, 255, 255, 0.15) inset,
                0 0 40px rgba(0, 128, 255, 0.7),
                inset 0 0 35px rgba(0, 128, 255, 0.25);
        }

        .game-card:hover::before {
            animation-duration: 5s;
        }

        .game-card:hover::after {
            animation-duration: 6s;
            filter: blur(0.5px);
        }

        .game-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            display: block;
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #ffffff;
            font-weight: 600;
        }

        .game-card p {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.4;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .game-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin: 1rem 0;
        }

        /* Game Control Sections */
        .math-controls, .memory-controls, .garden-controls {
            text-align: center;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .math-controls.active, .memory-controls.active, .garden-controls.active {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Math Game Styles */
        .math-controls {
            text-align: center;
            margin-top: 1rem;
        }

        .math-question {
            font-size: 2rem;
            font-weight: bold;
            margin: 1rem 0;
            color: #ffffff;
        }

        .math-input {
            padding: 12px 20px;
            font-size: 1.2rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            text-align: center;
            margin: 0 1rem;
            width: 150px;
        }

        .math-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .math-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .shoot-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            font-size: 1.2rem;
        }

        /* Responsive Game Grid */
        @media (max-width: 768px) {
            .game-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 1rem;
            }

            .game-card {
                padding: 1.5rem;
            }

            .game-header {
                flex-direction: column;
                text-align: center;
            }

            .game-buttons {
                flex-direction: column;
                align-items: center;
            }
        }

        /* Responsive Design for Games */
        @media (max-width: 768px) {
            .games-title {
                font-size: 2rem;
            }

            .game-container {
                padding: 1.5rem;
                margin: 1rem;
            }

            #gameCanvas {
                width: 100%;
                max-width: 400px;
                height: auto;
            }

            .mobile-controls {
                display: flex;
            }

            .game-info {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 0.5rem;
                padding: 0.8rem;
            }

            .score, .lives, .level, .timer, .pairs, .moves, .plants, .water, .seeds {
                font-size: 0.9rem;
                padding: 0.3rem;
            }

            .math-input {
                width: 120px;
                margin: 0.5rem;
            }
        }

        @media (max-width: 480px) {
            .games-title {
                font-size: 1.8rem;
            }

            .game-container {
                padding: 1rem;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            .shoot-btn {
                width: 70px;
                height: 70px;
                font-size: 1rem;
            }

            .game-info {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.3rem;
                padding: 0.5rem;
            }

            .score, .lives, .level, .timer, .pairs, .moves, .plants, .water, .seeds {
                font-size: 0.8rem;
                padding: 0.2rem;
            }

            .nav-button {
                padding: 12px 25px;
                font-size: 1rem;
                margin: 1.5rem 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Play Games</h1>
        <div class="accent-line"></div>

        <!-- Navigation -->
        <a href="index.html" class="nav-button">‚Üê Back to Home</a>

        <!-- Game Lobby -->
        <div id="gameLobby" class="games-section">
            <h2 class="games-title">üéÆ Choose Your Game üéÆ</h2>

            <div class="game-grid">
                <div class="game-card" data-game="math">
                    <div class="game-icon">üìö</div>
                    <h3>Math Challenge</h3>
                    <p>Solve math problems against the clock</p>
                </div>

                <div class="game-card" data-game="memory">
                    <div class="game-icon">üß†</div>
                    <h3>Memory Game</h3>
                    <p>Match pairs of cards to test your memory</p>
                </div>

                <div class="game-card" data-game="sports">
                    <div class="game-icon">‚öΩ</div>
                    <h3>Sports Champion</h3>
                    <p>Score goals past the goalkeeper</p>
                </div>

                <div class="game-card" data-game="garden">
                    <div class="game-icon">üå±</div>
                    <h3>Garden Grower</h3>
                    <p>Plant, water, and harvest your garden</p>
                </div>

                <div class="game-card" data-game="space">
                    <div class="game-icon">üöÄ</div>
                    <h3>Space Adventure</h3>
                    <p>Navigate through space collecting treasures</p>
                </div>

                <div class="game-card" data-game="time">
                    <div class="game-icon">‚è∞</div>
                    <h3>Time Travel</h3>
                    <p>Journey through different time periods</p>
                </div>
            </div>
        </div>

        <!-- Game Container -->
        <div id="gameContainer" class="game-container" style="display: none;">
            <div class="game-header">
                <h2 id="currentGameTitle" class="games-title">üéÆ Game üéÆ</h2>
                <button id="backToLobby" class="nav-button">‚Üê Back to Games</button>
            </div>

            <div class="game-info">
                <div class="score">Score: <span id="score">0</span></div>
                <div class="lives">Lives: <span id="lives">3</span></div>
                <div class="level">Level: <span id="level">1</span></div>
                <div id="timer" class="timer">Time: <span id="timeLeft">60</span>s</div>
                <div id="pairsFound" class="pairs">Pairs: <span>0</span></div>
                <div id="moves" class="moves">Moves: <span>0</span></div>
                <div id="plantCount" class="plants">Plants: <span>0</span></div>
                <div id="waterLevel" class="water">Water: <span>100</span></div>
                <div id="seedCount" class="seeds">Seeds: <span>5</span></div>
            </div>

            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <div class="game-controls">
                <div id="gameInstructions">
                    <h3>üïπÔ∏è How to Play</h3>
                    <p>Select a game to see instructions</p>
                </div>

                <div class="game-buttons">
                    <button id="startBtn" class="game-button">Start Game</button>
                    <button id="pauseBtn" class="game-button">Pause</button>
                    <button id="restartBtn" class="game-button">Restart</button>
                </div>

                <!-- Math Game Controls -->
                <div id="mathControls" class="math-controls">
                    <div id="mathQuestion" class="math-question">Ready to start?</div>
                    <input type="number" id="mathAnswer" class="math-input" placeholder="Your answer">
                    <button id="submitAnswer" class="game-button">Submit</button>
                </div>

                <!-- Memory Game Controls -->
                <div id="memoryControls" class="memory-controls">
                    <p>Click on the canvas to flip cards and find matching pairs!</p>
                </div>

                <!-- Garden Game Controls -->
                <div id="gardenControls" class="garden-controls">
                    <button id="plantSeed" class="game-button">üå± Plant</button>
                    <button id="waterPlants" class="game-button">üíß Water</button>
                    <button id="harvestPlants" class="game-button">üåæ Harvest</button>
                </div>

                <!-- Mobile Controls -->
                <div class="mobile-controls">
                    <button class="control-btn" id="leftBtn">‚Üê</button>
                    <button class="control-btn shoot-btn" id="actionBtn">üéÆ</button>
                    <button class="control-btn" id="rightBtn">‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <script>

        // Game Manager - handles switching between games
        class GameManager {
            constructor() {
                this.currentGame = null;
                this.gameType = null;
                this.init();
            }

            init() {
                this.setupGameSelection();
                this.setupBackButton();
            }

            setupGameSelection() {
                const gameCards = document.querySelectorAll('.game-card');
                gameCards.forEach(card => {
                    card.addEventListener('click', () => {
                        const gameType = card.dataset.game;
                        this.startGame(gameType);
                    });
                });
            }

            setupBackButton() {
                document.getElementById('backToLobby').addEventListener('click', () => {
                    this.returnToLobby();
                });
            }

            startGame(gameType) {
                this.gameType = gameType;
                document.getElementById('gameLobby').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';

                // Clean up previous game
                if (this.currentGame && this.currentGame.cleanup) {
                    this.currentGame.cleanup();
                }

                // Hide all game-specific controls by removing active class
                document.getElementById('mathControls').classList.remove('active');
                document.getElementById('memoryControls').classList.remove('active');
                document.getElementById('gardenControls').classList.remove('active');

                // Hide all game-specific stats
                document.getElementById('timer').classList.remove('active');
                document.getElementById('pairsFound').classList.remove('active');
                document.getElementById('moves').classList.remove('active');
                document.getElementById('plantCount').classList.remove('active');
                document.getElementById('waterLevel').classList.remove('active');
                document.getElementById('seedCount').classList.remove('active');

                // Update mobile control button
                const actionBtn = document.getElementById('actionBtn');
                switch(gameType) {
                    case 'space':
                        actionBtn.innerHTML = 'üöÄ';
                        break;
                    case 'sports':
                        actionBtn.innerHTML = '‚öΩ';
                        break;
                    case 'garden':
                        actionBtn.innerHTML = 'üå±';
                        break;
                    case 'time':
                        actionBtn.innerHTML = '‚è∞';
                        break;
                    default:
                        actionBtn.innerHTML = 'üéÆ';
                }

                // Start the selected game
                switch(gameType) {
                    case 'math':
                        document.getElementById('currentGameTitle').textContent = 'üìö Math Challenge';
                        document.getElementById('mathControls').classList.add('active');
                        document.getElementById('timer').classList.add('active');
                        this.currentGame = new MathChallenge();
                        break;
                    case 'memory':
                        document.getElementById('currentGameTitle').textContent = 'üß† Memory Game';
                        document.getElementById('memoryControls').classList.add('active');
                        document.getElementById('pairsFound').classList.add('active');
                        document.getElementById('moves').classList.add('active');
                        this.currentGame = new MemoryGame();
                        break;
                    case 'sports':
                        document.getElementById('currentGameTitle').textContent = '‚öΩ Sports Champion';
                        this.currentGame = new SportsChampion();
                        break;
                    case 'garden':
                        document.getElementById('currentGameTitle').textContent = 'üå± Garden Grower';
                        document.getElementById('gardenControls').classList.add('active');
                        document.getElementById('plantCount').classList.add('active');
                        document.getElementById('waterLevel').classList.add('active');
                        document.getElementById('seedCount').classList.add('active');
                        this.currentGame = new GardenGrower();
                        break;
                    case 'space':
                        document.getElementById('currentGameTitle').textContent = 'üöÄ Space Adventure';
                        this.currentGame = new SpaceAdventure();
                        break;
                    case 'time':
                        document.getElementById('currentGameTitle').textContent = '‚è∞ Time Travel';
                        this.currentGame = new TimeTravel();
                        break;
                }
            }

            returnToLobby() {
                if (this.currentGame && this.currentGame.cleanup) {
                    this.currentGame.cleanup();
                }
                this.currentGame = null;
                this.gameType = null;
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('gameLobby').style.display = 'block';
            }
        }

        // Enhanced Math Challenge Game with Particle Effects and Power-ups
        class MathChallenge {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.score = 0;
                this.level = 1;
                this.timeLeft = 90;
                this.currentQuestion = null;
                this.gameRunning = false;
                this.timerInterval = null;
                this.combo = 0;
                this.maxCombo = 0;
                this.streak = 0;
                this.particles = [];
                this.powerUps = [];
                this.activePowerUps = new Set();
                this.difficulty = 1;
                this.questionStartTime = 0;
                this.consecutiveCorrect = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
                this.flashEffect = { active: false, color: '', alpha: 0 };
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.updateUI();
                this.generateQuestion();
                this.gameLoop();
            }

            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>üßÆ Enhanced Math Challenge</h3>
                    <p>üî¢ Solve problems to build combos and unlock power-ups!</p>
                    <p>‚ö° Get 5 in a row for SPEED BOOST, 10 for DOUBLE POINTS!</p>
                    <p>üéØ Faster answers = bigger bonuses!</p>
                    <p>üèÜ Current Combo: <span id="comboDisplay">0</span> | Max: <span id="maxComboDisplay">0</span></p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('pauseBtn').onclick = () => this.togglePause();
                document.getElementById('restartBtn').onclick = () => this.resetGame();
                document.getElementById('submitAnswer').onclick = () => this.submitAnswer();
                document.getElementById('mathAnswer').onkeypress = (e) => {
                    if (e.key === 'Enter') this.submitAnswer();
                };
            }

            startGame() {
                this.gameRunning = true;
                this.timeLeft = 90;
                this.questionStartTime = Date.now();
                this.startTimer();
                document.getElementById('mathAnswer').focus();
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timeLeft--;
                    this.updateUI();
                    if (this.timeLeft <= 0) {
                        this.gameOver();
                    }
                }, 1000);
            }

            togglePause() {
                if (!this.gameRunning) return;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                } else {
                    this.startTimer();
                    this.questionStartTime = Date.now();
                }
            }

            resetGame() {
                this.score = 0;
                this.level = 1;
                this.timeLeft = 90;
                this.combo = 0;
                this.maxCombo = 0;
                this.streak = 0;
                this.particles = [];
                this.powerUps = [];
                this.activePowerUps.clear();
                this.difficulty = 1;
                this.consecutiveCorrect = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
                this.gameRunning = false;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                this.updateUI();
                this.generateQuestion();
            }

            generateQuestion() {
                this.totalQuestions++;
                const operations = ['+', '-', '*', '/'];
                const operation = operations[Math.floor(Math.random() * operations.length)];
                let num1, num2, answer;
                let complexity = Math.min(this.difficulty + this.level, 10);

                switch(operation) {
                    case '+':
                        num1 = Math.floor(Math.random() * (15 * complexity)) + 1;
                        num2 = Math.floor(Math.random() * (15 * complexity)) + 1;
                        answer = num1 + num2;
                        break;
                    case '-':
                        num1 = Math.floor(Math.random() * (15 * complexity)) + 20;
                        num2 = Math.floor(Math.random() * num1) + 1;
                        answer = num1 - num2;
                        break;
                    case '*':
                        num1 = Math.floor(Math.random() * (6 + complexity)) + 1;
                        num2 = Math.floor(Math.random() * (6 + complexity)) + 1;
                        answer = num1 * num2;
                        break;
                    case '/':
                        answer = Math.floor(Math.random() * (10 + complexity)) + 1;
                        num2 = Math.floor(Math.random() * (8 + complexity)) + 1;
                        num1 = answer * num2;
                        break;
                }

                let points = {
                    '+': 10, '-': 15, '*': 25, '/': 35
                }[operation];

                this.currentQuestion = {
                    text: `${num1} ${operation} ${num2} = ?`,
                    answer: answer,
                    points: points * complexity,
                    operation: operation
                };

                document.getElementById('mathQuestion').textContent = this.currentQuestion.text;
                document.getElementById('mathAnswer').value = '';
                this.questionStartTime = Date.now();
            }

            submitAnswer() {
                if (!this.gameRunning || !this.currentQuestion) return;

                const userAnswer = parseInt(document.getElementById('mathAnswer').value);
                const responseTime = Date.now() - this.questionStartTime;
                const timeBonus = Math.max(0, 5000 - responseTime) / 100;

                if (userAnswer === this.currentQuestion.answer) {
                    this.correctAnswers++;
                    this.consecutiveCorrect++;
                    this.combo++;
                    this.maxCombo = Math.max(this.maxCombo, this.combo);

                    let basePoints = this.currentQuestion.points;
                    let multiplier = 1;

                    // Combo multipliers
                    if (this.combo >= 20) multiplier = 4;
                    else if (this.combo >= 15) multiplier = 3;
                    else if (this.combo >= 10) multiplier = 2.5;
                    else if (this.combo >= 5) multiplier = 2;

                    // Power-up effects
                    if (this.activePowerUps.has('double')) multiplier *= 2;
                    if (this.activePowerUps.has('speed') && responseTime < 3000) multiplier *= 1.5;

                    let totalPoints = Math.floor((basePoints * multiplier) + timeBonus);
                    this.score += totalPoints;

                    this.createSuccessEffect(totalPoints, multiplier);
                    this.checkPowerUps();
                    this.createParticles(this.canvas.width/2, this.canvas.height/2, '#4ECDC4', totalPoints);

                    // Dynamic difficulty adjustment
                    if (this.consecutiveCorrect >= 3 && responseTime < 4000) {
                        this.difficulty = Math.min(this.difficulty + 0.2, 5);
                    }

                    // Level progression
                    if (this.score > this.level * 150) {
                        this.level++;
                        this.createLevelUpEffect();
                    }
                } else {
                    this.combo = 0;
                    this.consecutiveCorrect = 0;
                    this.streak = 0;
                    this.difficulty = Math.max(this.difficulty - 0.1, 1);
                    this.createErrorEffect();
                    this.createParticles(this.canvas.width/2, this.canvas.height/2, '#FF6B6B', 0);
                }

                this.generateQuestion();
                this.updateUI();
                document.getElementById('mathAnswer').focus();
            }

            checkPowerUps() {
                // Speed Boost: 5 consecutive correct
                if (this.consecutiveCorrect === 5 && !this.activePowerUps.has('speed')) {
                    this.activatePowerUp('speed', 15000);
                }

                // Double Points: 10 consecutive correct
                if (this.consecutiveCorrect === 10 && !this.activePowerUps.has('double')) {
                    this.activatePowerUp('double', 20000);
                }

                // Time Freeze: 15 consecutive correct
                if (this.consecutiveCorrect === 15 && !this.activePowerUps.has('freeze')) {
                    this.activatePowerUp('freeze', 10000);
                }
            }

            activatePowerUp(type, duration) {
                this.activePowerUps.add(type);
                this.createPowerUpEffect(type);

                if (type === 'freeze') {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                }

                setTimeout(() => {
                    this.activePowerUps.delete(type);
                    if (type === 'freeze' && this.gameRunning) {
                        this.startTimer();
                    }
                }, duration);
            }

            createSuccessEffect(points, multiplier) {
                this.flashEffect = { active: true, color: '#4ECDC4', alpha: 0.3 };
                setTimeout(() => this.flashEffect.active = false, 200);

                // Show floating score
                this.createFloatingText(`+${points}`, this.canvas.width/2, this.canvas.height/2 - 50, '#4ECDC4');
                if (multiplier > 1) {
                    this.createFloatingText(`x${multiplier.toFixed(1)}`, this.canvas.width/2, this.canvas.height/2 - 80, '#FFD700');
                }
            }

            createErrorEffect() {
                this.flashEffect = { active: true, color: '#FF6B6B', alpha: 0.3 };
                setTimeout(() => this.flashEffect.active = false, 200);
                this.createFloatingText('MISS!', this.canvas.width/2, this.canvas.height/2 - 50, '#FF6B6B');
            }

            createLevelUpEffect() {
                this.createParticles(this.canvas.width/2, this.canvas.height/2, '#FFD700', 50);
                this.createFloatingText(`LEVEL ${this.level}!`, this.canvas.width/2, this.canvas.height/2, '#FFD700');
            }

            createPowerUpEffect(type) {
                const messages = {
                    'speed': 'SPEED BOOST!',
                    'double': 'DOUBLE POINTS!',
                    'freeze': 'TIME FREEZE!'
                };
                const colors = {
                    'speed': '#00FF00',
                    'double': '#FFD700',
                    'freeze': '#00BFFF'
                };
                this.createFloatingText(messages[type], this.canvas.width/2, this.canvas.height/3, colors[type]);
                this.createParticles(this.canvas.width/2, this.canvas.height/3, colors[type], 30);
            }

            createParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 100,
                        y: y + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        color: color,
                        life: 1,
                        decay: 0.02,
                        size: Math.random() * 4 + 2
                    });
                }
            }

            createFloatingText(text, x, y, color) {
                this.particles.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: -2,
                    color: color,
                    life: 1,
                    decay: 0.015,
                    text: text,
                    size: 24
                });
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= p.decay;
                    p.vy += 0.1; // gravity for non-text particles

                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            renderParticles() {
                for (let p of this.particles) {
                    this.ctx.save();
                    this.ctx.globalAlpha = p.life;

                    if (p.text) {
                        this.ctx.font = `${p.size}px Arial`;
                        this.ctx.fillStyle = p.color;
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(p.text, p.x, p.y);
                    } else {
                        this.ctx.fillStyle = p.color;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                }
            }

            render() {
                // Clear canvas with gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1e3c72');
                gradient.addColorStop(0.5, '#2a5298');
                gradient.addColorStop(1, '#1a2238');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Flash effect
                if (this.flashEffect.active) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.flashEffect.alpha;
                    this.ctx.fillStyle = this.flashEffect.color;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                }

                // Render combo meter
                this.renderComboMeter();

                // Render power-up indicators
                this.renderPowerUps();

                // Render accuracy indicator
                this.renderAccuracy();

                // Render particles
                this.renderParticles();

                // Title screen
                if (!this.gameRunning) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('ENHANCED MATH CHALLENGE', this.canvas.width / 2, this.canvas.height / 2 - 50);
                    this.ctx.font = '18px Arial';
                    this.ctx.fillText('Build combos ‚Ä¢ Unlock power-ups ‚Ä¢ Master mathematics!', this.canvas.width / 2, this.canvas.height / 2 + 20);
                }
            }

            renderComboMeter() {
                if (this.combo > 0) {
                    const x = 50;
                    const y = 50;
                    const width = 200;
                    const height = 20;

                    // Background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(x, y, width, height);

                    // Combo bar
                    const comboProgress = Math.min(this.combo / 20, 1);
                    const gradient = this.ctx.createLinearGradient(x, y, x + width, y);
                    gradient.addColorStop(0, '#4ECDC4');
                    gradient.addColorStop(0.5, '#45B7D1');
                    gradient.addColorStop(1, '#FFD700');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x, y, width * comboProgress, height);

                    // Combo text
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`Combo: ${this.combo}`, x, y + 35);
                }
            }

            renderPowerUps() {
                let yOffset = 100;
                for (let powerUp of this.activePowerUps) {
                    const icons = {
                        'speed': '‚ö°',
                        'double': 'üí∞',
                        'freeze': '‚ùÑÔ∏è'
                    };
                    this.ctx.font = '24px Arial';
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(icons[powerUp], 50, yOffset);
                    yOffset += 30;
                }
            }

            renderAccuracy() {
                if (this.totalQuestions > 0) {
                    const accuracy = (this.correctAnswers / this.totalQuestions * 100).toFixed(1);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(`Accuracy: ${accuracy}%`, this.canvas.width - 50, 50);
                }
            }

            gameLoop() {
                this.updateParticles();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }

            gameOver() {
                this.gameRunning = false;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                const accuracy = this.totalQuestions > 0 ? (this.correctAnswers / this.totalQuestions * 100).toFixed(1) : 0;
                alert(`üéâ Game Complete! üéâ\n\nFinal Score: ${this.score}\nMax Combo: ${this.maxCombo}\nAccuracy: ${accuracy}%\nLevel Reached: ${this.level}`);
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('timeLeft').textContent = this.timeLeft;
                document.getElementById('comboDisplay').textContent = this.combo;
                document.getElementById('maxComboDisplay').textContent = this.maxCombo;
            }

            cleanup() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
            }
        }

        // Enhanced Memory Game with Animations and Advanced Features
        class MemoryGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cards = [];
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.moves = 0;
                this.score = 0;
                this.gameRunning = false;
                this.gridSize = 4;
                this.cardSize = 70;
                this.particles = [];
                this.animatingCards = new Set();
                this.chainBonus = 0;
                this.perfectMatches = 0;
                this.hintUsed = false;
                this.currentHint = null;
                this.streakMultiplier = 1;
                this.consecutiveMatches = 0;
                this.cardAnimations = new Map();
                this.backgroundParticles = [];
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.createCards();
                this.updateUI();
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>üß© How to Play Memory Game</h3>
                    <p>üÉè Click on cards to flip them and find matching pairs</p>
                    <p>üéØ Match all pairs with the fewest moves possible</p>
                    <p>‚≠ê Faster completion gives bonus points!</p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('restartBtn').onclick = () => this.resetGame();
                this.canvas.onclick = (e) => this.handleCardClick(e);
            }

            setupCanvas() {
                this.canvas.width = 400;
                this.canvas.height = 400;
            }

            createCards() {
                this.cards = [];
                const symbols = ['üê∂', 'üê±', 'üê≠', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê∏'];
                const cardPairs = [];

                for (let i = 0; i < (this.gridSize * this.gridSize) / 2; i++) {
                    cardPairs.push(symbols[i], symbols[i]);
                }

                for (let i = cardPairs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardPairs[i], cardPairs[j]] = [cardPairs[j], cardPairs[i]];
                }

                let index = 0;
                const spacing = this.canvas.width / this.gridSize;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        this.cards.push({
                            x: col * spacing + spacing/2 - this.cardSize/2,
                            y: row * spacing + spacing/2 - this.cardSize/2,
                            width: this.cardSize,
                            height: this.cardSize,
                            symbol: cardPairs[index],
                            flipped: false,
                            matched: false,
                            id: index
                        });
                        index++;
                    }
                }
            }

            startGame() {
                this.gameRunning = true;
                this.startTime = Date.now();
                this.render();
            }

            resetGame() {
                this.gameRunning = false;
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.moves = 0;
                this.score = 0;
                this.createCards();
                this.updateUI();
                this.render();
            }

            handleCardClick(e) {
                if (!this.gameRunning || this.flippedCards.length >= 2) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const clickedCard = this.cards.find(card =>
                    x >= card.x && x <= card.x + card.width &&
                    y >= card.y && y <= card.y + card.height &&
                    !card.flipped && !card.matched
                );

                if (clickedCard) {
                    this.flipCard(clickedCard);
                }
            }

            flipCard(card) {
                card.flipped = true;
                this.flippedCards.push(card);
                this.render();

                if (this.flippedCards.length === 2) {
                    this.moves++;
                    this.updateUI();

                    setTimeout(() => {
                        this.checkMatch();
                    }, 1000);
                }
            }

            checkMatch() {
                const [card1, card2] = this.flippedCards;

                if (card1.symbol === card2.symbol) {
                    card1.matched = true;
                    card2.matched = true;
                    this.matchedPairs++;
                    this.score += 100;

                    if (this.matchedPairs === (this.gridSize * this.gridSize) / 2) {
                        this.gameComplete();
                    }
                } else {
                    card1.flipped = false;
                    card2.flipped = false;
                }

                this.flippedCards = [];
                this.updateUI();
                this.render();
            }

            gameComplete() {
                const timeBonus = Math.max(0, 300 - Math.floor((Date.now() - this.startTime) / 1000));
                const moveBonus = Math.max(0, (this.gridSize * this.gridSize) * 10 - this.moves * 5);
                this.score += timeBonus + moveBonus;
                this.gameRunning = false;
                alert(`Congratulations! Score: ${this.score}\\nMoves: ${this.moves}\\nTime Bonus: ${timeBonus}`);
            }

            render() {
                this.ctx.fillStyle = 'rgba(30, 60, 114, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let card of this.cards) {
                    if (card.matched) {
                        this.ctx.fillStyle = '#4ECDC4';
                    } else if (card.flipped) {
                        this.ctx.fillStyle = '#ffffff';
                    } else {
                        this.ctx.fillStyle = '#667eea';
                    }

                    this.ctx.fillRect(card.x, card.y, card.width, card.height);
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(card.x, card.y, card.width, card.height);

                    if (card.flipped || card.matched) {
                        this.ctx.font = '30px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillStyle = '#000000';
                        this.ctx.fillText(
                            card.symbol,
                            card.x + card.width / 2,
                            card.y + card.height / 2 + 10
                        );
                    } else {
                        this.ctx.font = '40px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillText(
                            '?',
                            card.x + card.width / 2,
                            card.y + card.height / 2 + 15
                        );
                    }
                }
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('pairsFound').querySelector('span').textContent = this.matchedPairs;
                document.getElementById('moves').querySelector('span').textContent = this.moves;
            }
        }

        // Sports Champion Game
        class SportsChampion {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.score = 0;
                this.level = 1;
                this.kicks = 0;
                this.gameRunning = false;
                this.ball = null;
                this.goal = null;
                this.goalkeeper = null;
                this.powerBar = 0;
                this.chargingPower = false;
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.setupGameObjects();
                this.updateUI();
                this.gameLoop();
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>‚öΩ How to Play Sports Champion</h3>
                    <p>ü•Ö Click and hold to charge power, release to kick!</p>
                    <p>üéØ Aim for the corners to score past the goalkeeper</p>
                    <p>üèÜ Score 10 goals to advance to the next level</p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('restartBtn').onclick = () => this.resetGame();

                this.canvas.onmousedown = (e) => this.startCharging(e);
                this.canvas.onmouseup = (e) => this.kick(e);
                this.canvas.ontouchstart = (e) => this.startCharging(e.touches[0]);
                this.canvas.ontouchend = (e) => this.kick(e.changedTouches[0]);
            }

            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }

            setupGameObjects() {
                this.ball = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 100,
                    radius: 15,
                    vx: 0,
                    vy: 0,
                    moving: false
                };

                this.goal = {
                    x: this.canvas.width / 2 - 150,
                    y: 50,
                    width: 300,
                    height: 150
                };

                this.goalkeeper = {
                    x: this.canvas.width / 2,
                    y: this.goal.y + this.goal.height - 40,
                    width: 30,
                    height: 40,
                    vx: 2,
                    direction: 1
                };
            }

            startGame() {
                this.gameRunning = true;
            }

            resetGame() {
                this.score = 0;
                this.level = 1;
                this.kicks = 0;
                this.gameRunning = false;
                this.setupGameObjects();
                this.powerBar = 0;
                this.chargingPower = false;
                this.updateUI();
            }

            startCharging(e) {
                if (!this.gameRunning || this.ball.moving) return;
                this.chargingPower = true;
                this.powerBar = 0;
            }

            kick(e) {
                if (!this.gameRunning || !this.chargingPower || this.ball.moving) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const dx = x - this.ball.x;
                const dy = y - this.ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const power = Math.min(this.powerBar / 100, 1);
                const speed = power * 15;

                this.ball.vx = (dx / distance) * speed;
                this.ball.vy = (dy / distance) * speed;
                this.ball.moving = true;

                this.kicks++;
                this.chargingPower = false;
                this.powerBar = 0;
            }

            update() {
                if (!this.gameRunning) return;

                if (this.chargingPower) {
                    this.powerBar = Math.min(this.powerBar + 3, 100);
                }

                this.goalkeeper.x += this.goalkeeper.vx * this.goalkeeper.direction;
                if (this.goalkeeper.x <= this.goal.x + 20 ||
                    this.goalkeeper.x >= this.goal.x + this.goal.width - 50) {
                    this.goalkeeper.direction *= -1;
                }

                if (this.ball.moving) {
                    this.ball.x += this.ball.vx;
                    this.ball.y += this.ball.vy;

                    this.ball.vy += 0.2;
                    this.ball.vx *= 0.99;

                    this.checkCollisions();
                }
            }

            checkCollisions() {
                if (this.ball.x >= this.goal.x &&
                    this.ball.x <= this.goal.x + this.goal.width &&
                    this.ball.y >= this.goal.y &&
                    this.ball.y <= this.goal.y + this.goal.height) {

                    const goalkeeperHit = this.ball.x >= this.goalkeeper.x - 20 &&
                                         this.ball.x <= this.goalkeeper.x + this.goalkeeper.width + 20 &&
                                         this.ball.y >= this.goalkeeper.y - 20 &&
                                         this.ball.y <= this.goalkeeper.y + this.goalkeeper.height + 20;

                    if (!goalkeeperHit) {
                        this.score += 10;
                        alert('GOAL! üéâ');

                        if (this.score >= this.level * 100) {
                            this.level++;
                            this.goalkeeper.vx += 0.5;
                        }
                    }

                    this.resetBall();
                }

                if (this.ball.x < 0 || this.ball.x > this.canvas.width ||
                    this.ball.y > this.canvas.height) {
                    this.resetBall();
                }
            }

            resetBall() {
                this.ball.x = this.canvas.width / 2;
                this.ball.y = this.canvas.height - 100;
                this.ball.vx = 0;
                this.ball.vy = 0;
                this.ball.moving = false;
            }

            render() {
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 5;
                this.ctx.strokeRect(this.goal.x, this.goal.y, this.goal.width, this.goal.height);

                this.ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const x = this.goal.x + (i * this.goal.width / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.goal.y);
                    this.ctx.lineTo(x, this.goal.y + this.goal.height);
                    this.ctx.stroke();
                }

                this.ctx.fillStyle = '#FF9800';
                this.ctx.fillRect(this.goalkeeper.x, this.goalkeeper.y,
                                 this.goalkeeper.width, this.goalkeeper.height);

                this.ctx.fillStyle = '#000000';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                this.ctx.fill();

                if (this.chargingPower) {
                    const barWidth = 200;
                    const barHeight = 20;
                    const barX = this.canvas.width / 2 - barWidth / 2;
                    const barY = this.canvas.height - 50;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(barX, barY, barWidth, barHeight);

                    this.ctx.fillStyle = this.powerBar > 80 ? '#FF5722' :
                                       this.powerBar > 50 ? '#FF9800' : '#4CAF50';
                    this.ctx.fillRect(barX, barY, (barWidth * this.powerBar / 100), barHeight);
                }

                if (!this.gameRunning) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('SPORTS CHAMPION', this.canvas.width / 2, this.canvas.height / 2 - 50);
                }
            }

            gameLoop() {
                this.update();
                this.render();
                this.updateUI();
                requestAnimationFrame(() => this.gameLoop());
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.kicks;
            }
        }

        // Garden Grower Game
        class GardenGrower {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.plants = [];
                this.score = 0;
                this.level = 1;
                this.water = 100;
                this.seeds = 5;
                this.gameRunning = false;
                this.mode = 'plant';
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.createGarden();
                this.updateUI();
                this.gameLoop();
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>üåª How to Play Garden Grower</h3>
                    <p>üå± Click on empty plots to plant seeds</p>
                    <p>üíß Water your plants to help them grow</p>
                    <p>üåæ Harvest mature plants for points and seeds</p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('restartBtn').onclick = () => this.resetGame();
                document.getElementById('plantSeed').onclick = () => this.plantMode();
                document.getElementById('waterPlants').onclick = () => this.waterMode();
                document.getElementById('harvestPlants').onclick = () => this.harvestMode();
                this.canvas.onclick = (e) => this.handlePlotClick(e);
            }

            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }

            createGarden() {
                this.plots = [];
                const cols = 8;
                const rows = 6;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        this.plots.push({
                            x: col * 100 + 10,
                            y: row * 100 + 10,
                            width: 80,
                            height: 80,
                            plant: null,
                            watered: 0
                        });
                    }
                }
            }

            startGame() {
                this.gameRunning = true;
            }

            resetGame() {
                this.plants = [];
                this.score = 0;
                this.level = 1;
                this.water = 100;
                this.seeds = 5;
                this.gameRunning = false;
                this.createGarden();
                this.updateUI();
            }

            plantMode() {
                this.mode = 'plant';
            }

            waterMode() {
                this.mode = 'water';
            }

            harvestMode() {
                this.mode = 'harvest';
            }

            handlePlotClick(e) {
                if (!this.gameRunning) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const clickedPlot = this.plots.find(plot =>
                    x >= plot.x && x <= plot.x + plot.width &&
                    y >= plot.y && y <= plot.y + plot.height
                );

                if (clickedPlot) {
                    this.handlePlotAction(clickedPlot);
                }
            }

            handlePlotAction(plot) {
                switch(this.mode) {
                    case 'plant':
                        if (!plot.plant && this.seeds > 0) {
                            plot.plant = {
                                type: Math.floor(Math.random() * 4),
                                growth: 0,
                                maxGrowth: 100,
                                watered: false,
                                plantedTime: Date.now()
                            };
                            this.seeds--;
                        }
                        break;
                    case 'water':
                        if (plot.plant && this.water > 0 && !plot.plant.watered) {
                            plot.plant.watered = true;
                            plot.watered = Date.now();
                            this.water -= 10;
                        }
                        break;
                    case 'harvest':
                        if (plot.plant && plot.plant.growth >= plot.plant.maxGrowth) {
                            const plantType = plot.plant.type;
                            this.score += (plantType + 1) * 25;
                            this.seeds += 2;
                            plot.plant = null;
                            plot.watered = 0;
                        }
                        break;
                }
            }

            update() {
                if (!this.gameRunning) return;

                const currentTime = Date.now();

                for (let plot of this.plots) {
                    if (plot.plant) {
                        const growthRate = plot.plant.watered ? 0.5 : 0.1;
                        plot.plant.growth = Math.min(
                            plot.plant.growth + growthRate,
                            plot.plant.maxGrowth
                        );

                        if (plot.plant.watered && currentTime - plot.watered > 10000) {
                            plot.plant.watered = false;
                        }
                    }
                }

                if (this.water < 100) {
                    this.water = Math.min(this.water + 0.1, 100);
                }
            }

            render() {
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let plot of this.plots) {
                    this.ctx.fillStyle = plot.plant ? '#654321' : '#A0522D';
                    this.ctx.fillRect(plot.x, plot.y, plot.width, plot.height);

                    if (plot.plant) {
                        const plant = plot.plant;
                        const plantTypes = [
                            { symbol: 'üåπ', mature: 'üå∫' },
                            { symbol: 'üå±', mature: 'üåø' },
                            { symbol: 'üåæ', mature: 'üåæ' },
                            { symbol: 'üåµ', mature: 'üå≤' }
                        ];

                        const type = plantTypes[plant.type];
                        const size = 20 + (plant.growth / plant.maxGrowth) * 30;

                        this.ctx.font = `${size}px Arial`;
                        this.ctx.textAlign = 'center';
                        const symbol = plant.growth >= plant.maxGrowth ? type.mature : type.symbol;
                        this.ctx.fillText(symbol, plot.x + plot.width/2, plot.y + plot.height/2 + 5);

                        if (plant.watered) {
                            this.ctx.font = '16px Arial';
                            this.ctx.fillText('üíß', plot.x + plot.width - 10, plot.y + 20);
                        }
                    }
                }

                if (!this.gameRunning) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GARDEN GROWER', this.canvas.width / 2, this.canvas.height / 2 - 50);
                }
            }

            gameLoop() {
                this.update();
                this.render();
                this.updateUI();
                requestAnimationFrame(() => this.gameLoop());
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('plantCount').querySelector('span').textContent = this.plots.filter(p => p.plant).length;
                document.getElementById('waterLevel').querySelector('span').textContent = Math.floor(this.water);
                document.getElementById('seedCount').querySelector('span').textContent = this.seeds;
            }
        }

        // Space Adventure Game
        class SpaceAdventure {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.gameRunning = false;
                this.player = null;
                this.asteroids = [];
                this.treasures = [];
                this.keys = {};
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.createPlayer();
                this.updateUI();
                this.gameLoop();
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>üöÄ How to Play Space Adventure</h3>
                    <p>üéÆ Use arrow keys or touch controls to navigate</p>
                    <p>üíé Collect treasures for points</p>
                    <p>‚òÑÔ∏è Avoid asteroids or lose a life!</p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('restartBtn').onclick = () => this.resetGame();

                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }

            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }

            createPlayer() {
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 100,
                    width: 40,
                    height: 40,
                    speed: 5
                };
            }

            startGame() {
                this.gameRunning = true;
                this.spawnTimer = 0;
            }

            resetGame() {
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.gameRunning = false;
                this.asteroids = [];
                this.treasures = [];
                this.createPlayer();
                this.updateUI();
            }

            update() {
                if (!this.gameRunning) return;

                if (this.keys['ArrowLeft'] && this.player.x > 20) {
                    this.player.x -= this.player.speed;
                }
                if (this.keys['ArrowRight'] && this.player.x < this.canvas.width - 60) {
                    this.player.x += this.player.speed;
                }
                if (this.keys['ArrowUp'] && this.player.y > 20) {
                    this.player.y -= this.player.speed;
                }
                if (this.keys['ArrowDown'] && this.player.y < this.canvas.height - 60) {
                    this.player.y += this.player.speed;
                }

                this.spawnTimer++;
                if (this.spawnTimer % 60 === 0) {
                    this.spawnAsteroid();
                }
                if (this.spawnTimer % 90 === 0) {
                    this.spawnTreasure();
                }

                for (let i = this.asteroids.length - 1; i >= 0; i--) {
                    const asteroid = this.asteroids[i];
                    asteroid.y += asteroid.speed;

                    if (asteroid.y > this.canvas.height) {
                        this.asteroids.splice(i, 1);
                    }
                }

                for (let i = this.treasures.length - 1; i >= 0; i--) {
                    const treasure = this.treasures[i];
                    treasure.y += treasure.speed;

                    if (treasure.y > this.canvas.height) {
                        this.treasures.splice(i, 1);
                    }
                }

                this.checkCollisions();
            }

            spawnAsteroid() {
                this.asteroids.push({
                    x: Math.random() * (this.canvas.width - 60),
                    y: -30,
                    size: 20 + Math.random() * 20,
                    speed: 2 + Math.random() * 3
                });
            }

            spawnTreasure() {
                this.treasures.push({
                    x: Math.random() * (this.canvas.width - 30),
                    y: -20,
                    size: 15,
                    speed: 1 + Math.random() * 2,
                    type: Math.floor(Math.random() * 3)
                });
            }

            checkCollisions() {
                for (let i = this.asteroids.length - 1; i >= 0; i--) {
                    const asteroid = this.asteroids[i];
                    if (this.isColliding(this.player, asteroid)) {
                        this.lives--;
                        this.asteroids.splice(i, 1);

                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                }

                for (let i = this.treasures.length - 1; i >= 0; i--) {
                    const treasure = this.treasures[i];
                    if (this.isColliding(this.player, treasure)) {
                        const points = (treasure.type + 1) * 50;
                        this.score += points;
                        this.treasures.splice(i, 1);

                        if (this.score >= this.level * 1000) {
                            this.level++;
                        }
                    }
                }
            }

            isColliding(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (obj1.width || obj1.size) / 2 + (obj2.width || obj2.size) / 2;
            }

            gameOver() {
                this.gameRunning = false;
                alert(`Game Over! Final Score: ${this.score}`);
            }

            render() {
                this.ctx.fillStyle = '#000011';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = 'white';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 13) % this.canvas.width;
                    const y = (i * 17 + this.spawnTimer) % this.canvas.height;
                    this.ctx.fillRect(x, y, 2, 2);
                }

                this.ctx.fillStyle = '#4ECDC4';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                for (let asteroid of this.asteroids) {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(asteroid.x, asteroid.y, asteroid.size, asteroid.size);
                }

                for (let treasure of this.treasures) {
                    const symbols = ['üíé', '‚≠ê', 'üîπ'];
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(symbols[treasure.type], treasure.x, treasure.y);
                }

                if (!this.gameRunning) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('SPACE ADVENTURE', this.canvas.width / 2, this.canvas.height / 2 - 50);
                }
            }

            gameLoop() {
                this.update();
                this.render();
                this.updateUI();
                requestAnimationFrame(() => this.gameLoop());
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.lives;
            }
        }

        // Time Travel Game
        class TimeTravel {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.score = 0;
                this.level = 1;
                this.artifacts = 0;
                this.gameRunning = false;
                this.player = null;
                this.timeArtifacts = [];
                this.obstacles = [];
                this.currentPeriod = 0;
                this.timePeriods = [
                    { name: 'Prehistoric', color: '#8B4513', bg: '#654321' },
                    { name: 'Ancient Egypt', color: '#FFD700', bg: '#FFA500' },
                    { name: 'Medieval', color: '#708090', bg: '#2F4F4F' },
                    { name: 'Renaissance', color: '#FF6347', bg: '#DC143C' },
                    { name: 'Modern', color: '#4169E1', bg: '#191970' },
                    { name: 'Future', color: '#00CED1', bg: '#008B8B' }
                ];
                this.init();
            }

            init() {
                this.updateGameInstructions();
                this.setupEventListeners();
                this.setupCanvas();
                this.createPlayer();
                this.updateUI();
                this.gameLoop();
            }

            updateGameInstructions() {
                document.getElementById('gameInstructions').innerHTML = `
                    <h3>‚è∞ How to Play Time Travel</h3>
                    <p>üèÉ Click to move through different time periods</p>
                    <p>üè∫ Collect historical artifacts for points</p>
                    <p>‚ö†Ô∏è Avoid time paradoxes and obstacles</p>
                `;
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('restartBtn').onclick = () => this.resetGame();
                this.canvas.onclick = (e) => this.handleClick(e);
            }

            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }

            createPlayer() {
                this.player = {
                    x: 100,
                    y: this.canvas.height / 2,
                    width: 30,
                    height: 30,
                    targetY: this.canvas.height / 2,
                    speed: 3
                };
            }

            startGame() {
                this.gameRunning = true;
                this.spawnTimer = 0;
                this.periodTimer = 0;
            }

            resetGame() {
                this.score = 0;
                this.level = 1;
                this.artifacts = 0;
                this.gameRunning = false;
                this.currentPeriod = 0;
                this.timeArtifacts = [];
                this.obstacles = [];
                this.createPlayer();
                this.updateUI();
            }

            handleClick(e) {
                if (!this.gameRunning) return;

                const rect = this.canvas.getBoundingClientRect();
                const y = e.clientY - rect.top;
                this.player.targetY = y - this.player.height / 2;
            }

            update() {
                if (!this.gameRunning) return;

                const dy = this.player.targetY - this.player.y;
                if (Math.abs(dy) > 2) {
                    this.player.y += dy * 0.1;
                }

                this.player.y = Math.max(0, Math.min(this.canvas.height - this.player.height, this.player.y));

                this.periodTimer++;
                if (this.periodTimer > 600) {
                    this.currentPeriod = (this.currentPeriod + 1) % this.timePeriods.length;
                    this.periodTimer = 0;
                    this.level++;
                }

                this.spawnTimer++;
                if (this.spawnTimer % 90 === 0) {
                    this.spawnArtifact();
                }
                if (this.spawnTimer % 120 === 0) {
                    this.spawnObstacle();
                }

                for (let i = this.timeArtifacts.length - 1; i >= 0; i--) {
                    const artifact = this.timeArtifacts[i];
                    artifact.x -= artifact.speed;

                    if (artifact.x < -50) {
                        this.timeArtifacts.splice(i, 1);
                    }
                }

                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= obstacle.speed;

                    if (obstacle.x < -50) {
                        this.obstacles.splice(i, 1);
                    }
                }

                this.checkCollisions();
            }

            spawnArtifact() {
                const period = this.timePeriods[this.currentPeriod];
                const artifacts = {
                    'Prehistoric': ['ü¶¥', 'üèπ', 'üî•'],
                    'Ancient Egypt': ['üè∫', 'üëë', 'üìú'],
                    'Medieval': ['‚öîÔ∏è', 'üõ°Ô∏è', 'üè∞'],
                    'Renaissance': ['üé®', 'üìñ', 'üî≠'],
                    'Modern': ['üì±', 'üí°', 'üöó'],
                    'Future': ['üöÄ', 'ü§ñ', 'üíé']
                };

                const periodArtifacts = artifacts[period.name] || ['‚≠ê'];

                this.timeArtifacts.push({
                    x: this.canvas.width,
                    y: Math.random() * (this.canvas.height - 60) + 30,
                    symbol: periodArtifacts[Math.floor(Math.random() * periodArtifacts.length)],
                    speed: 2 + Math.random() * 2,
                    points: 50
                });
            }

            spawnObstacle() {
                this.obstacles.push({
                    x: this.canvas.width,
                    y: Math.random() * (this.canvas.height - 80) + 40,
                    width: 30,
                    height: 30,
                    speed: 3 + Math.random() * 2
                });
            }

            checkCollisions() {
                for (let i = this.timeArtifacts.length - 1; i >= 0; i--) {
                    const artifact = this.timeArtifacts[i];
                    if (this.isColliding(this.player, artifact)) {
                        this.score += artifact.points;
                        this.artifacts++;
                        this.timeArtifacts.splice(i, 1);
                    }
                }

                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    if (this.isColliding(this.player, obstacle)) {
                        this.score = Math.max(0, this.score - 100);
                        this.obstacles.splice(i, 1);
                    }
                }
            }

            isColliding(obj1, obj2) {
                return obj1.x < obj2.x + (obj2.width || 30) &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + (obj2.height || 30) &&
                       obj1.y + obj1.height > obj2.y;
            }

            render() {
                const period = this.timePeriods[this.currentPeriod];

                this.ctx.fillStyle = period.bg;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(0, 0, this.canvas.width, 40);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`Time Period: ${period.name}`, this.canvas.width / 2, 28);

                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);

                for (let artifact of this.timeArtifacts) {
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(artifact.symbol, artifact.x + 15, artifact.y + 15);
                }

                for (let obstacle of this.obstacles) {
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('‚ö†Ô∏è', obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2 + 5);
                }

                if (!this.gameRunning) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '36px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('TIME TRAVEL ADVENTURE', this.canvas.width / 2, this.canvas.height / 2 - 50);
                }
            }

            gameLoop() {
                this.update();
                this.render();
                this.updateUI();
                requestAnimationFrame(() => this.gameLoop());
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.artifacts;
            }
        }

        // Initialize the game manager when the page loads
        window.addEventListener('load', () => {
            window.gameManager = new GameManager();
        });
    </script>
</body>
</html>